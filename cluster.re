
= フェイルオーバー

== フェイルオーバー概観

Couchbase Serverにおけるフェイルオーバーの解説に進む前に、まず分散アーキテクチャー一般におけるフェイルオーバーについて、一般に妥当すると考えられる前提や要件などを整理します。

まず、広い意味でのフェールオーバーとして、以下の２種類があります。

=== 計画的なノード削除（グレースフルフェイルオーバー）

クラスタから機能しているノードを削除するには、管理コンソール等を利用し、削除するノードを指定します。
その後クラスタをリバランスし、これまで、そのノードへ行われていたリクエストが他のノードで処理できるようにします。

削除対象ノードは、リバランスが完了するまでデータリクエストを処理することができます。完了時点で、他のノードでリクエストが処理されることになります。
すなわち、サービスが中断するようなことも、データを消失してしまうこともなく、ノードを削除してクラスタを（グレースフルに）リバランスできます。

Couchbase Serverで、機能しているノードを計画的に削除したい場合、フェイルオーバー(Failover)ではなく、ノード削除(Remove)の後、リバランスを実行します。

=== 障害時のノード削除（ハードフェイルオーバー）

フェイルオーバーとは、そのノードをクラスタから削除し、他のノードにあるレプリケートしたデータを利用可能にすることです。

フェイルオーバーはノードの削除とは異なり、正常に動作していないノードに対して実行します。（機能しているノードをフェイルオーバした場合、フェイルオーバは即座にノードをクラスタから削除するため、データロスが発生する可能性があります。）

ノード障害時に他のノードへレプリケートされていないデータが存在していた場合データロスとなります（フェールオーバーしたノード上で、ディスクに永続化されていた場合、そのサーバーが復旧出来た場合には、データを復旧できる可能性があります（デルタリカバリー）。そうでない場合データは、完全に消失することになります。

以下、上記のハードフェイルオーバーに関する論点を整理していきます。

=== フェイルオーバー実行方法と考慮点

ノード障害発生時には、クラスタを縮退稼働させるために、フェイルオーバーを手動で実行するか、あるいは、ソフトウェアにより自動的にフェイルオーバーをトリガーすることが考えられます。
フェイルオーバーはクラスタの性能を縮小させてしまうため、フェイルオーバーの状況をどのように処理すべきかはよく検討するべきです。

 * @<strong>{自動フェイルオーバー}を利用すると、ユーザ操作なしにノードをフェイルオーバーできますが、ノード障害を発生させた問題の調査や特定は難しくなります。
 * @<strong>{手動フェイルオーバー}によりクラスターを管理する場合、クラスターを監視し、問題の発生を検知できるようにします。問題が発生したら、手動（あるいは外部スクリプト）でフェイルオーバーを実行します。この手法では、より多くの監視や手動の操作が必要です。


=== 連鎖反応(Thundering Herd)

自動でコンポーネントを取り除くには、どんな分散システムでも問題が付き物です。
問題の原因を特定できない場合、または残りのシステムにかかる負荷を理解していない場合、自動フェイルオーバーは問題を解決するどころか、より多くの問題を発生させる可能性があります。
次のような状況では、問題を誘発する可能性があります。

クラスタが、キャパシティの80-90%で稼働しているとします。その時点で、順調に稼働していたとしても、クラスタのキャパシティは限界です。
ノード障害が発生し、ソフトウェアが自動的にノードをフェイルオーバーしたとします。
残りの4ノードでは負荷が増大し、正常に処理することはできないでしょう。
結果として負荷が増加することで、他のノードもダウンし、自動的にフェイルオーバーされてしまいます。
これらの障害は連鎖し、結果的にクラスタ全体の消失へとつながる可能性があります。

この場合の次善策は、単一ノード障害が発生してもクラスタの運用を続け、新しいサーバをクラスタに追加し、失われたキャパシティを補填して、ダウンしたノードを削除し、リバランスを実行することです。
こうすれば、クラスタ全体が利用不可となる代わりに、部分的な障害で済みます。単一ノード障害発生時には、一部のリクエストを処理できない方が、クラスタ全体の障害によってまったくリクエストを処理できないことよりも良いと言えます。

このような状況の予防策としては、ノード障害発生時にも十分な余剰のキャパシティを確保し、縮退運転ができるようにすることです。

=== ソフトウェアによる自動発動

ネットワークデバイスの故障が原因でネットワークが分割されてしまう、ネットワーク分断やスプリットブレインの状況を考慮し、分散アーキテクチャーを持つソフトウェアの多くでは、以下の制約付きで自動フェイルオーバーを実装しています。

 * 自動フェイルオーバーは最低でも1クラスタに3台のノードを必要とする。これは、ネットワーク分断が発生した際に、2ノードのクラスタがお互いのノードをフェイルオーバーすることを防ぎます。クラスターによって、データのセットが構成されている場合、これはデータの整合性と一貫性を保護するために重要です。
 * 自動フェイルオーバーは（データのレプリカが存在するなど）発動後もサービスが継続可能な場合のみ実行される。
 * 自動フェイルオーバーは管理操作を必要とする前に一度だけ発動する。これは、フェイルオーバーの連鎖による、以後の性能や安定性の劣化を防ぐためです。多くの場合、クラスタが機能できなくなるまで劣化し続けるよりも、データセットの小さな部分にアクセスできなくなる方が望ましいでしょう。
 * 自動フェイルオーバーを実行するまでに一定の待機時間を設ける。これは一時的なネットワーク障害や、システムの遅延によって、誤ってノードがフェイルオーバーされることを防ぎます。

=== 保守運用

保守要員による運用では、アラートに対する次の行動に関する意思決定者の役割が重要になります。
適切な人員配置により、広範囲のデータ、観測、経験を生かして、最適な方法で状況を解決することができます。

組織において、しかるべき担当者による影響関係に対する判断を伴わない、システムによるフェイルオーバーの自動化が許可されていないことも珍しくありません。

=== 外部システム連携

クラスターをモニタリングし、一定の発動条件に基づき、フェイルオーバーを実行するために、外部システムを利用することも考えられます

外部システム利用には、クラスター以外の要素に関しても考慮できるという面での優位性があります。
例えば、外部システムは、クラスターが依存するネットワークスイッチがダウンしていることを検知するかもしれません。
このような場合、ノードをフェイルオーバーしても状況は改善しないことが分かるため、フェイルオーバーを実行しないという判断が可能になります。
モニタリングシステムが、問題は単一のノードだけで起きており、クラスターを縮退させても、残りのノードで集約したトラフィックを処理できると判断した上で、REST APIやコマンドラインツールを利用してノードをフェイルオーバーすることもできます。

=== 復旧

フェイルオーバー実行により、クラスタが縮退運転している間、クラスタ内に残る稼働中のノードに対する負荷は増大します。
クラスタがノード障害前と同じ状態で機能するためには、正常に機能するノードをクラスターに戻し、リバランスを実行して、ノード障害から復旧する必要があります。

手動でフェイルオーバーを実行しても、クラスタが自動的に実行するようにしても、障害の原因を解明する必要があります。
そして、正常に機能するノードをセットアップし、そのノードを追加し、クラスタをリバランスします。

フェイルオーバーシナリオに対処する際の、ノードの交換および追加に関する選択肢を以下に記します。

 * ハードウェアやシステム障害が起因してノードがダウンした場合、新規の交換用ノードをクラスタに追加してリバランスする。
 * クラスタのキャパシティ不足が原因でノードがダウンした場合、ノードの交換に加え、必要なキャパシティとするために必要な分だけノードを追加する。
 * ノードの障害が一時的なものである場合、そのノードをクラスタに再追加します。

== 自動フェイルオーバー

=== 有効化設定

Couchbase Serverの自動フェイルオーバーは、デフォルトでは無効となっています。
これは、自動フェイルオーバーの発生による影響関係を理解した上で、自動フェイルオーバーが明示的に有効とされるまで、自動フェイルオーバーが発生することを防止するためです。

=== 実行条件

自動フェイルオーバー実行には、いくつかの条件があります。これは自動フェイルオーバーが実行された際に発生する可能性のある問題を回避するためです。

下記のようなケースでは、自動フェイルオーバーがトリガーされません。

 * @<strong>{イベント同時発生} 複数のイベントが同時に発生した場合、自動フェイルオーバーはトリガーされません。
 * @<strong>{フェイルオーバー連続実行} 管理者が指定したイベントの最大数までしか、自動フェイルオーバーはトリガーされません。許可される最大の最大値は3です。この自動フェイルオーバーの最大数に達すると、管理者がカウントを手動でリセットするまで、自動フェイルオーバーは発生しません。ただし、最大数に達する前にカウントを手動でリセットできます。
 * @<strong>{データ損失発生可能性} データ損失が発生する可能性のある状況では自動フェイルオーバーは発生しません。たとえば、バケットにレプリカがない場合はこのケースです。
 * @<strong>{非フェールオーバーノードの応答状況} （フェールオーバー対象となる）ノードが応答しなくなった後でも、ノードの過半数に接続できる場合のみ、自動フェールオーバーがトリガーされます（グループの場合、グループが応答しなくなった後でも、グループの過半数に連絡できる場合のみ）。

=== 待機時間

ノードが自動フェイルオーバーされるまでに、最低でも30秒の遅延時間が必要とされます。
適切な待機時間を設定することは、サーバーやネットワークの一時的な問題により、機能しているノードをフェイルオーバーしてしまうことを防ぐために重要です。

=== 通知

REST APIを利用して、ノード障害が発生し、ノードが自動でフェイルオーバーされた際にCouchbase Serverがメールで通知を送信するように設定することができます。

=== サービス固有ポリシー

応答しないノード上の1つまたは複数のサービスのサービス固有の自動フェイルオーバーポリシーに準拠して自動フェイルオーバーがトリガーされます。

Couchbase Serverでは、マルチディメンショナルスケーリング(MDS)により、ノード毎に配置するサービスを選択することが可能です。
ノードのフェイルオーバーの挙動は、そのノード上で稼働しているサービスが自動フェイルオーバーに対応しているかどうかにより決定されます。

====[column]エディションによる差異
コミュニティエディションでは、マルチディメンショナルスケーリング(MDS)は利用できないことから、Dataサービスのポリシーに準拠することになります。

====[/column]

 * @<strong>{Dataサービス}では、自動フェイルオーバーが有効化されるためには、最低３ノードが必要です。

 * @<strong>{Indexサービス}では、自動フェイルオーバーはサポートされません。

 * @<strong>{その他のサービス}（Query、Service、Analytics、Eventing）のフェイルオーバーには、最低２ノードが必要です。

=== グループフェイルオーバー

ノードをラック（アベイラビリティゾーン）毎にグループ化することにより、グループフェイルオーバーの機能を活用することができます。

グループフェイルオーバーは、デフォルトでは無効とされています。

グループに多数のノードが含まれている場合でも、グループフェイルオーバーは単一のイベントと見なされます。

====[column]エディションによる差異
グループフェイルオーバーは、エンタープライズエディションでのみ使用できます。

====[/column]

=== ディスク障害に対するフェイルオーバー

クラスター単位で有効化することにより、ディスク障害に対する自動フェイルオーバーの機能を活用することができます。

====[column]エディションによる差異
ディスク障害に対するフェイルオーバーは、エンタープライズエディションでのみ使用できます。

====[/column]

== 手動フェイルオーバー

Couchbase Serverのフェイルオーバーは以下の方法で手動で実行できます。

=== Webコンソール

 * WebコンソールのServersメニューに移動します。ノード一覧が表示され、クラスタがDownとして判定したノードのみFail Overボタンが有効になります。フェイルオーバーしたいノードのFail Overボタンをクリックします。
 * 確認・警告メッセージが表示されます。
 * FailOverをクリックし、ノードをフェイルオーバーします。Cancelを選択することもできます。

=== コマンドラインツール

@<tt>{couchbase-cli} の @<tt>{failover}サブコマンドを利用して、ノードをフェイルオーバーすることができます。
ノードをフェイルオーバーするには、フェイルオーバーするノードのIPアドレス（および標準ポート番号を利用していない場合はポート番号）を指定します。


//emlist{
couchbase-cli failover --cluster=<server(available)>:8091\
-u cluster-username -p cluster-password\
--server-failover=<server(target)>:8091
//}

成功すると、ノードがフェイルオーバーされたことを示すメッセージが表示されます。

