

= Couchbase Serverの構成要素

== Dataサービス

Dataサービスは、Couchbase Serverの管理するデータへのアクセスを提供します。

Dataサービスは、全てのCouchbaseサービスにおいて、最も基本的なものです。Dataサービスは、クラスターを構成する全てのノードのうち、少なくともひとつのノードで実行される必要があります。

Dataサービスは、以下の３つのコンポーネントからなります。

//blankline

 * ディスパッチャー(Dispatcher)
 * KV(キーバリュー)エンジン(KV Engine)
 * スケジューラー(Scheduler)

=== ディスパッチャー

 * Dataサービスへのリクエストを受けとり、レスポンスします。
 * DCP(Database Change Protocol)を使用して、クラスター内の他のノードおよび他のクラスターにデータをストリーミングします。
 * 認証を処理します。

=== KVエンジン

バケットに関する以下の機能を提供します。

//blankline

 * @<strong>{マネージドキャッシュ}は、設定されたクォータに従って、バケットに割り当てられたメモリーです。アイテムが書き込まれると、アイテムはまずキャッシュに入り、その後、ひとつ以上の他のノードに複製するために、複製キューに配置されます。さらに（揮発性のEphemeralバケットではなく、Couchbaseバケットの場合）ディスクキューを介して、ディスクに書き込まれます。また、クラスター全体のさまざまなノード上のバケットアイテムの場所が記録されている、パーティションハッシュテーブルも、このマネージドキャッシュに含まれます。
 * @<strong>{チェックポイントマネージャー}は、アイテムの変更を追跡します。チェックポイントには、まだレプリケーションキューとディスクキューに配置されていないメモリー内の変更が記録されます。
 * @<strong>{アイテムページャー}は、最近使用されていないアイテムを、必要に応じてメモリーから取り除き、スペースを解放します。
 * @<strong>{フラッシャー}は、バケット内のすべてのアイテムを一括削除することができます。バケットのデフォルト設定では、フラッシュ処理は無効になっています。
 * @<strong>{有効期限(Expiry)ページャー}は、期限切れのアイテムをスキャンし、メモリーとディスクから消去します。有効期限ページャーは、デフォルトで60分ごとに実行されます。
 * @<strong>{バッチリーダー}は、ディスクキューに溜まっている複数のアイテムに加えられた変更を、ディスクに書き込むために、バッチとして結合することにより、パフォーマンスを向上させます。

=== スケジューラー

Dataサービスのスケジューラーは、以下の4種類のスレッドからなります。これらのスレッドは、互いに独立して、影響を与えずに実行されます。

//blankline

 * @<strong>{Reader IO} ディスクから情報を読み取るスレッド
 * @<strong>{Writer IO} ディスクに情報を書き込むスレッド
 * @<strong>{Non IO} ディスクアクセスを必要としない処理(接続通知、チェックポイントの削除、ハッシュテーブルのサイズ変更など)を行うスレッド
 * @<strong>{Aux IO (補助 auxiliary IO)} 補助的な処理(フェッチ、スキャン、バックフィルタスク等)を行うスレッド

== Queryサービス

Queryサービスは、N1QLクエリ言語によるクエリをサポートします。

Queryサービスは次の３つの構成要素からなります。

//blankline

 * リスナー
 * クエリプロセッサ
 * データストア


=== リスナー

クエリ要求を受信します。

=== クエリプロセッサ

クエリプロセッサは、受信されたクエリが有効なステートメントであるかどうかを判定するために、クエリに@<strong>{パーサー}を適用します。
そして、利用可能な実行パスを評価する@<strong>{オプティマイザー}を用いて、待ち時間が最も短いパスを決定します。
さらに、決定されたパスを使用してクエリ実行プランを生成し、計画を一連の操作（オペレーター）にまとめます。
最後に、@<strong>{実行エンジン}がオペレーターを受け取り、実行します。


=== データストア

データソースへのアクセスを提供します。 データソースには、Couchbase Serverのデータ、インデックス、認証情報等が含まれます。

=== 他のサービスとの連携

Queryサービス内部の処理は、他のサービスと連携しながら、以下のように行われます(可能な場合、処理は並行で実行されます)。

//blankline

 1. クエリプロセッサによる解析ルーチンを実行して、リクエストされたステートメントを検証の上、実行プランを作成します。
 2. Indexサービスにアクセスして、関連するインデックスに対してスキャン操作を実行します。
 3. Dataサービスにアクセスして、フェッチ操作を実行し、返されたデータを結合操作で使用します。
 4. フィルタリング、集約、ソートなどの追加の処理を実行します。

====[column]エディションによる差異

コミュニティーエディションではクエリの並列実行におけるリソース利用は、最大４コアに制限されているのに対して、エンタープライズエディションではこの制限がありません。

このことは、コミュニティーエディションでは、ノード上のDataサービスを無効にすることができません。そのため、QueryサービスとDataサービスは、常に同じハードウェアリソースを共有している、という事実と考え合わせて理解することができます。

====[/column]


== Indexサービス

Indexサービスは、Queryサービスと連携してN1QLクエリを実行するためのインデックス（データへの索引）機能を提供します。

Indexサービスは、以下の３つのプロセスからなります。

//blankline

 * スーパーバイザー
 * プロジェクター
 * ルーター

=== スーパーバイザー

スーパーバイザーはIndexサービスのメインプログラムです。Indexサービスノードで稼働し、以下の役割を持ちます。

//blankline

 * インデックス定義の管理
 * インデックス作成・保存
 * インデックス更新
 * Queryサービスからのリクエストへの応答

//blankline

インデックス作成時には、まずQueryサービスから、スーパーバイザーに対してインデックス作成リクエストが送られます。
その後、スーパーバイザーはインデックス定義をプロジェクターとルーターに渡します。

=== プロジェクターとルーター

プロジェクターとルーターは、Dataノード上で実行されるプロセスです。
スーパーバイザーによって提供されるインデックス定義に従って、Indexサービスにデータを提供します。

プロジェクターとルーターは、Dataサービスによって提供されるDCPストリームを継続的に監視します。
DCPストリーム上のデータミューテーション（更新）情報が、インデックスのターゲットを含む場合には、プロジェクターとルーターが、そのデータをスーパーバイザーに送信して、スーパーバイザーがインデックスを更新します。

インデックスが作成されていない場合、プロジェクターとルーターは何もしません。

以下は、Indexノードのスーパーバイザー、Dataノードのプロジェクターとルーター、およびQueryサービスとの間のコミュニケーションの概念図です。

//image[services-relationship][サービス間連携]{
//}

(画像は、 Couchbase Under the Hood: An Architectural Overview@<fn>{server-arc-overview}より引用)



== クラスターマネージャー

クラスターマネージャーは、クラスターを構成する全てのノード上に存在します。

クラスターマネージャーは、次のふたつのプロセスで構成されています。

//blankline

 * ns-server
 * babysitter

=== ns-server

ns-serverは、クラスターマネージャーの中心となるプロセスであり、以下の機能を持ちます。

//blankline

 * @<strong>{マスターサービス}: フェイルオーバー、リバランス、バケットの追加と削除など、クラスター全体に影響を与える操作を管理します。常に、クラスター上のノードのひとつだけがマスターサービスの役割を担当します。マスターサービスは、ノード間でのネゴシエーションの上、決定されます。選出されたノードが使用できなくなった場合は、別のノードが引き継ぎます。マスターサービスは、オーケストレーターと呼ばれることもあります。

 * @<strong>{REST API管理}: クラスター管理に関するREST APIサービスを提供します。このREST APIは、Webコンソールで提供される機能とコマンドラインインターフェイスの両方の基礎になっています。Couchbase Serverでは、REST APIインターフェースを受け持つ特別なノードはありません。

 * @<strong>{認可}: ロールベースのアクセス制御でノードのリソースを保護します。

=== babysitter

babysitterは、Couchbase Serverの様々なプロセスの保守を担当します。

保守の対象には、クラスターマネージャーのもうひとつのプロセスであるns-serverを含みます。

babysitterは、以下の役割を持ちます。

//blankline

 * プロセスを監視し、監視ログ出力をbabysitter.logに記録します。
 * プロセスのいずれかが停止した場合、そのプロセスを起動します。

== マスターサービス

マスターサービスとして選出されたクラスターマネージャーは、独自の役割を果たします。

マスターサービスの役割は、下記のように大別されます。

//blankline

 * @<strong>{サービス管理}: ノードの現在の状態を管理し、プロセスとサービスの監視と再起動を処理します。

 * @<strong>{バケット管理}: バケットレベルの操作、レプリケーション、フェイルオーバー、再起動、および統計収集などを処理します。

以下に、マスターサービスが行ういくつかの処理の概要を記します。

=== クラスタートポロジー管理

マスターサービスは、クラスターのメンバー構成に責任を持ちます。クラスターのトポロジーが変更されると、既存のワークロードの処理を継続しながら、クラスターの再構成を行います。

クラスターに新しくDataノード(Dataサービスが稼働しているノード)が追加される際には、マスターサービスがリバランスを開始し、新しいvBucketマップレイアウトを計算します。
その後、新しいvBucketマップレイアウトに従って、既存のノードから追加されたノードへのvBucketのコピーが開始されます。
vBucketのコピーが完了すると、古いvBucketから新しいvBucketへのスイッチオーバーが発生します。新しいvBucketがアクティブになると、マスターサービスは新しいvBucketマップをすべてのノードとクライアントに通知します。


Dataノードをクラスターのメンバーから取り外すプロセスでは、維持されるノードで新たにvBucketが作成され、削除されるノードからデータが移動されます。削除対象ノードからデータがなくなった後に、そのノードはクラスターから削除されます。

=== ノード障害検出

Couchbase Serverクラスター内のノードは、ハートビートメカニズムによってステータスが管理されます。ハートビートは、全てのノード上のクラスターマネージャーから定期的に提供されます。各ハートビートには、ノードの状態を評価するために使用される基本的な情報が含まれています。

マスターサービスは、他のすべてのノードから受信したハートビートを追跡します。自動フェイルオーバーが有効になっていて、デフォルトのタイムアウト期間より長くノードからハートビートが受信されない場合、マスターサービスはノードをフェイルオーバーの対象としてマークし、実行可能な条件が整っている場合、自動フェイルオーバーを行います。

=== バケット管理

マスターサービスはvBucketファイルの配置をコントロールします。
vBucketの配置は、クラスタートポロジーが変更されるたびに、次のルールによって再編成されます。

//blankline

 * アクティブvBucketとレプリカvBucketは別々のノードに配置されます。
 * ２個以上のレプリカ構成の場合、レプリカvBucketはそれぞれ別々のノードに配置されます。
 * サーバーグループが定義されている場合、アクティブvBucketとレプリカvBucketは別のグループに配置されます。

=== 管理、統計、およびロギング

クラスターマネージャーは、構成管理、統計収集、およびロギングサービスを一元化し、管理を簡素化します。
すべての構成変更はマスターサービスによって管理され、マスターサービスノードから他のノードに通知されます。

//footnote[server-arc-overview][https://resources.couchbase.com/c/server-arc-overview?x=V3nd_e]

