

= Couchbase Serverの構成要素

== Dataサービス

Dataサービスは、Couchbase　Serverの管理するデータへのアクセスを提供します。ここで扱われるデータは、メモリ、あるいはディスク上に存在します。Dataサービスへのメモリの割り当ては設定により調整することが可能です。
Dataサービスは、全てのCouchbaseサービスにおいて、最も基本的なものです。Dataサービスは、クラスターを構成する全てのノードのうち、少なくとも1つのノードで実行される必要があります。

Couchbase Serverは、ドキュメント指向型に分類されるNoSQLでありながら、その最も基本的な部分では、純粋なKVS（キーバリューストア）として、設計されています（バリューとしてJSONドキュメントを格納することによって、Queryサービス等のJSON関連機能を活用することができますが、バリューには、バイナリデータを格納することも可能です）。

=== 構成

Dataサービスは、以下の３つのコンポーネントからなります。

 * ディスパッチャ(Dispatcher)
 * KV(キーバリュー)エンジン(KV Engine)
 * スケジューラー(Scheduler)

==== ディスパッチャー

 * Dataサービスへのリクエストを受けとり、応答を提供します。
 * DCP(Database Change Protocol)を使用して、クラスター内の他のノードおよび他のクラスターにデータをストリーミングします。
 * 認証を処理します。

==== KVエンジン

バケットに関する以下の機能を提供します。

 * @<strong>{マネージドキャッシュ} マネージドキャッシュは、設定されたクォータに従って、バケットに割り当てられたメモリです。これには、パーティションハッシュテーブルが含まれています。これにより、メモリ内およびディスク上の、クラスター全体のさまざまなノード上のバケットアイテムの場所が記録されます。アイテムが書き込まれると、アイテムはまずキャッシュに入り、その後、1つ以上の他のノードに複製するために、複製キューに配置されます。さらに（揮発性のエフェメラル型バケットではなく、デフォルトのCouchbase型バケットの場合）ディスクキューを介して、ディスクに書き込まれます。
 * @<strong>{チェックポイントマネージャ} チェックポイントマネージャは、チェックポイント(checkpoint)という名称のデータ(構造)を使用して、アイテムの変更を追跡します。チェックポイントには、メモリ内のアイテムとして加えられ、まだレプリケーションキューとディスクキューに配置されていない変更が記録されます。
 * @<strong>{アイテムページャー} 必要に応じてスペースを解放するために、最近使用されていないアイテムをメモリから取り除きます。
 * @<strong>{フラッシャー} バケット内のすべてのアイテムを一括削除します。バケットのデフォルト設定では、フラッシュ処理は無効になっています。
 * @<strong>{有効期限(Expiry)ページャー} 期限切れのアイテムをスキャンし、メモリとディスクから消去します。その後、トゥームストーンは、デフォルトの3日間残ります。有効期限ページャーは、デフォルトで60分ごとに実行されます。
 * @<strong>{バッチリーダー} ディスクキューに溜まっている複数のアイテムに加えられた変更を、ディスクに書き込むために、バッチとして結合することにより、パフォーマンスを向上させます。

==== スケジューラー

主にI/Oを処理するためのスレッドのプールです。スレッドは4種類に分けられ、互いに独立して、影響を与えずに実行されます。

 * @<strong>{Non IO} ディスクアクセスを必要としないスケジューラー専用のタスクです。接続通知、チェックポイントの削除、ハッシュテーブルのサイズ変更などが含まれます。
 * @<strong>{Aux IO (補助 auxiliary IO)} フェッチ、スキャン、およびバックフィルタスク等、補助的な処理を担います。
 * @<strong>{Reader IO} ディスクから情報を読み取るスレッド。
 * @<strong>{Writer IO} ディスクに情報を書き込むスレッド。

== Queryサービス

Couchbase Serverは、ドキュメント指向型に分類されるNoSQLでありながら、N1QLというSQLをJSONに対して拡張したクエリ言語を用いて、JSONデータに対するクエリを実行することができます。

Queryサービスは、N1QLクエリ言語によるクエリをサポートします。

=== 構成

Queryサービスは次の３つの構成要素からなります。

 * リスナー
 * クエリプロセッサ
 * データストア

==== リスナー

クエリ要求を受信します。

==== クエリプロセッサ

有効なステートメントであるかどうかを判断するために、受信されたクエリに@<strong>{パーサー}を適用します。
また、利用可能な実行パスを評価する@<strong>{オプティマイザー}を用いて、待ち時間が最も短いパスを決定します。
さらに、決定された待ち時間が最も短いパスを使用によってクエリ実行プランを生成し、計画を一連の操作（オペレータ）にまとめます。
@<strong>{実行エンジン}は、オペレータを受け取り、それを実行します。

==== データストア

データソースへのアクセスを提供します。 @<strong>{Couchbase Serverストア}が、Couchbase Serverのデータ、インデックス、認証情報を処理するために使用されます。
また、他のデータストアとして、@<strong>{ローカルファイルシステム}等も含まれます。

=== クエリの実行

Queryサービス内部の処理、及び他のサービスとの連携の内容は、以下の通りです。

 * クエリプロセッサは、解析ルーチンを実行して、リクエストされたステートメントを検証の上、実行プランを作成します。
 * Indexサービスにアクセスして、関連するインデックスに対してスキャン操作を実行します。
 * Dataサービスにアクセスしてフェッチ操作を実行し、返されたデータを結合操作で使用します。
 * Queryサービスは、Filter、Aggregate、Sortなどの追加の処理を実行します。

可能な場合、処理は並行で実行されます。

== Indexサービス

Indexサービスは、Queryサービスと連携してN1QLクエリを実行するためのインデックス（データへの索引）機能を提供します。
Dataサービスで生じるデータの変更に際して、DCP(データチェンジプロトコル)を介して、データの変更を反映し、インデックスが更新されます。

=== 構成

Indexサービスは、以下の３つのプロセスからなります。

 * スーパーバイザー
 * プロジェクター
 * ルーター

==== スーパーバイザー

スーパーバイザーはIndexサービスのメインプログラムです。Indexサービスノードで稼働し、以下の役割を持ちます。

 * インデックス定義の管理
 * インデックス作成・保存
 * インデックス更新
 * Queryサービスからのリクエストへの対応

==== プロジェクターとルーター

プロジェクターとルーターはDataサービス・ノード上で実行されるプロセスです。
スーパーバイザーによって提供されるインデックス定義に従って、Indexサービスにデータを提供します。
インデックスが作成されていない場合、プロジェクターとルーターは何もしません。

以下は、IndexサービスのスーパーバイザーとDataサービスのプロジェクター・ルーターおよびQueryサービスとの間のコミュニケーションの概念図です。

//image[services-relationship][services relationship]{
//}

(画像は、 Couchbase Under the Hood: An Architectural Overview@<fn>{server-arc-overview}より引用)

=== 他サービスとの連携

==== インデックス作成時

Queryサービスから、スーパーバイザーに対して、インデックス作成リクエストが送られます。
インデックスの初回作成時、スーパーバイザーがインデックス定義をプロジェクターとルーターに渡します。

==== データ更新時

プロジェクターとルーターは、Dataサービスによって提供されるDCPストリームを継続的に監視します。DCPストリーム上のデータミューテーション（更新）情報が、インデックスフィールドへのミューテーションを含む場合には、プロジェクターとルーターは、そのデータをスーパーバイザーに送信して、スーパーバイザーがインデックスを更新します。

==== インデックス利用時

Queryサービスから、スーパーバイザーに対して、リクエストが送られ、スーパーバイザーがQueryサービスへインデックス情報を返します。

=== ストレージ

Indexサービスは、標準ストレージまたはメモリ最適化ストレージのいずれかを使用するように構成できます。

==== 標準ストレージ

個々のインデックスに加えられたすべての変更をディスクに保持します。各インデックスは専用のファイルからなります。

 * コミュニティでは、インデックス作成時に、追加書き込み専用(append-only)モード、あるいは循環再利用(circular-reuse)モードの何かを選択します。
 * エンタープライズエディションでは、自動的に圧縮処理されます。

==== メモリ最適化ストレージ

EnterpriseEditionでのみ使用できます。インデックスはメモリに保存されます。これにより、メンテナンス、スキャン、および変更の効率が向上します。インデックスのスナップショットはディスク上に保持され、ノード障害が発生した場合に迅速に回復できるようにします。メモリ最適化ストレージには、メモリ消費の最適化のため、skiplist（Bツリー）構造が使用されています。

== クラスターマネージャー

クラスターマネージャーは、クラスターを構成する全てのノード上に存在します。
他の分散アーキテクチャーで見られるマスター/スレーブ（マスター/ワーカー）構成のような、管理するノードと管理されるノードからなる構成とは異なっています。
（後に詳しく触れますが）全てのノードに存在するクラスターマネージャー（インスタンス）の中から、マスターサービスとしてのクラスターマネージャー（インスタンス）が選出されます。

クラスターマネージャーは次の2つのプロセスで構成されています。

 * ns-server
 * babysitter

=== ns-server

クラスターマネージャーの中心となるプロセスはns-serverであり、その構成は次のとおりです。

@<strong>{マスターサービス}

フェイルオーバー、リバランス、バケットの追加と削除など、クラスター全体に影響を与える運用を管理します。
常に、クラスター上のノードの1つだけがマスターサービスの役割を担当します。マスターサービスは、ノード間でのネゴシエーションの上、決定されます。選出されたノードが使用できなくなった場合は、別のノードが引き継ぎます。
マスターサービスは、オーケストレーターと呼ばれることもあります。

@<strong>{REST管理（UIおよびCLI）}

REST APIによる管理機能を提供します。これは、Couchbase
Webコンソールによって提供されるユーザーインターフェイスとCouchbaseコマンドラインインターフェイスの両方の基礎になっています。

@<strong>{認証（Authentication）}

ロールベースのアクセス制御でノードのリソースを保護します。各ロールはさまざまなシステム権限に関連付けられています。資格情報（ユーザー名とパスワード）に基づいて、ロールが割り当てられます。

=== babysitter

babysitterは、CouchbaseServerの様々なプロセスの保守を担当します。
（保守の対象には、クラスターマネージャーのもう一つのプロセスであるns-serverを含みます。）

 * プロセスを監視し、監視ログ出力をbabysitter.logに記録します。
 * プロセスのいずれかが停止した場合、そのプロセスを起動します。

babysitterの位置づけとして特徴的なのは、babysitterは、クラスターの概念とは独立しており（クラスターの一部であることが意識される役割を持っているわけではなく）、純粋に、そのノードで稼働しているサービスの保守を行っているということです。

=== マスターサービスの役割

マスターサービスの役割を大別すると下記があります。

 * @<strong>{サービス管理} ノードの現在の状態を管理し、そのプロセスとサービスの監視と再起動を処理します。

 * @<strong>{バケット管理} バケットレベルの操作を管理します。レプリケーション、フェイルオーバー、再起動、および統計収集をサポートします。

また、以下のような面についても、マスターサービスの役割として理解しておくことは重要です。

 * @<strong>{分散処理機能一般} ノードの検出、構成変更に関するメッセージングとアラート、レプリケーション、ハートビートの送信をサポートします。

 * @<strong>{ローカル機能一般} ローカルに提供される機能（ライブラリ、ワークキュー、ロギング、クロック、ID、およびイベント）をサポートします。

=== クラスターメンバー管理

選出されたマスターサービスは、クラスターのメンバー構成に責任があります。クラスターのトポロジーが変更されると、既存のワークロードの処理を継続しながら、一連の操作が実行され、クラスターの再構成が行われます。

==== ノードの追加

 1. マスターサービスは、リバランスを開始し、vBucketマップを再計算します。
 2. データを受信するノードは、各vBucketの既存のノードからDCPレプリケーションストリームを開始し、それらのvBucketの新しいコピーの作成を開始します。これは、新しいvBucketマップレイアウトに応じて、アクティブvBucketとレプリカvBucketの両方で発生します。
 3. 新しいアクティブvBucketでデータが更新されるたびに、そのデータは複製され、関係するインデックスが更新されます。
 4. 新しいvBucketの更新が完了すると、古いvBucketから新しいvBucketへのスイッチオーバーが発生します。
 5. 新しいノード上の新しいvBucketがアクティブになると、マスターサービスは、新しいvBucketマップがすべてのノードとクライアントに通知されるように通知します。
 6. 以上のプロセスは、リバランスが完了するまで繰り返されます。

==== ノードの削除

Dataサービスノードを削除するプロセスは、追加するプロセスと似ています。維持されるノードで新たにvBucketsが作成され、削除されるノードのvBucketsからデータが移動されます。削除対象ノードから、vBucketがなくなった後に、そのノードはクラスターから削除されます。

Dataサービスをホストしないノードを追加または削除する場合、データは移動されません。したがって、ノードはデータ移管なしでクラスターに追加またはクラスターから削除されます。

==== ノード障害の検出

Couchbase Serverクラスター内のノードは、ハートビートメカニズムによってステータスが管理されます。ハートビートは、全てのノード上のクラスターマネージャーから定期的に提供されます。各ハートビートには、ノードの状態を評価するために使用される基本的な情報が含まれています。

マスターサービスは、他のすべてのノードから受信したハートビートを追跡します。自動フェイルオーバーが有効になっていて、デフォルトのタイムアウト期間より長くノードからハートビートが受信されない場合、マスターサービスはノードをフェイルオーバーの対象としてマークし、自動フェールオーバーを行います（有効化されており実行可能な条件が整っている場合）。

=== バケット管理

Couchbase Serverバケットは、物理的に1024個のマスターvBucketファイルと、レプリカvBucketファイルからなります。マスターサービスは可用性とリバランスのパフォーマンスを最大化するために、これらのvBucketsの配置をコントロールします。vBucketの配置は、クラスタートポロジーが変更されるたびに、次のルールによって再編成されます。

 * マスターとレプリカのvBucketは別々のノードに配置されます。
 * ２個以上のレプリカ構成の場合、レプリカvBucketはそれぞれ別々のノードに配置されます。
 * マスターvBucketに対してサーバーグループが定義されている場合、レプリカvBucketは別のグループに配置されます。

=== 管理、統計、およびロギング

クラスターマネージャーは、構成管理、統計収集、およびロギングサービスを一元化し、管理を簡素化します。すべての構成変更はマスターサービスによって管理され、マスターサービスノードから他のノードにプッシュされます。

//footnote[server-arc-overview][https://resources.couchbase.com/c/server-arc-overview?x=V3nd_e]

